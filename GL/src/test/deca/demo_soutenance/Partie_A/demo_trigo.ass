; start main program
	TSTO #19
	BOV stack_overflow_error
	ADDSP #15
;  ************************************************************
;  *           CONSTRUCTION DES VTABLES DES CLASSES           *
;  ************************************************************
; Construction de la VTable de la classe Object
	LOAD #null, R0	;     // On garde Dans R0 l'addr de la classe Object pour eviter de le loader a chaque fois !! 
	STORE R0, 1(GB)
	LOAD code.Object.equals, R1	;     // On garde Dans R1 le label 'code.Object.equals' pour la meme raison 
	STORE R1, 2(GB)
; Construction de la VTable de Math
	LEA 1(GB), R2
	STORE R2, 3(GB)
	STORE R1, 4(GB)
	LOAD code.Math.sin, R2
	STORE R2, 5(GB)
	LOAD code.Math.cos, R2
	STORE R2, 6(GB)
	LOAD code.Math.atan, R2
	STORE R2, 7(GB)
	LOAD code.Math.asin_asm, R2
	STORE R2, 8(GB)
	LOAD code.Math.asin, R2
	STORE R2, 9(GB)
	LOAD code.Math.ulp, R2
	STORE R2, 10(GB)
; Variable Declarations : 
	NEW #2, R2
	BOV tas_plein
	LEA 3(GB), R3
	STORE R3, 0(R2)
	PUSH R2
	BSR init.Math
	POP R2
	STORE R2, 11(GB)
; Beginning of main instructions:
	WSTR "===== DEMONSTRATION EXTENSION TRIGO ====="
	WNL
	WNL
	WSTR "--- Test asin : erreur de domaine ---"
	WNL
	ADDSP #2
	LOAD 11(GB), R2
	STORE R2, 0(SP)
	LOAD #0x1.0p-1, R0
	STORE R0, -1(SP)
	LOAD 0(SP), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 0(R2), R2
	BSR 6(R2)
	SUBSP #2
	STORE R0, 12(GB)
	ADDSP #2
	LOAD 11(GB), R2
	STORE R2, 0(SP)
	LOAD #0x1.0p-1, R0
	STORE R0, -1(SP)
	LOAD 0(SP), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 0(R2), R2
	BSR 6(R2)
	SUBSP #2
	STORE R0, 12(GB)
	WSTR "asin(0.5) = "
	LOAD 12(GB), R2
	LOAD R2, R1
	WFLOAT
	WNL
	LOAD 11(GB), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 1(R2), R2
	LOAD #6, R3
	FLOAT R3, R3
	BOV overflow_error
	LOAD R3, R1
	CMP #0x0.0p0, R1
	BEQ div_zero_error
	DIV R3, R2
	BOV overflow_error
	LOAD 12(GB), R3
	SUB R3, R2
	BOV overflow_error
	STORE R2, 15(GB)
	WSTR "Erreur absolue = "
	LOAD 15(GB), R2
	LOAD R2, R1
	WFLOAT
	WNL
	ADDSP #2
	LOAD 11(GB), R2
	STORE R2, 0(SP)
	LOAD 11(GB), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 1(R2), R2
	LOAD #6, R3
	FLOAT R3, R3
	BOV overflow_error
	LOAD R3, R1
	CMP #0x0.0p0, R1
	BEQ div_zero_error
	DIV R3, R2
	BOV overflow_error
	STORE R2, -1(SP)
	LOAD 0(SP), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 0(R2), R2
	BSR 7(R2)
	SUBSP #2
	STORE R0, 14(GB)
	WSTR "ULP(asin(0.5)) = "
	LOAD 14(GB), R2
	LOAD R2, R1
	WFLOAT
	WNL
	WSTR "L'erreur en ULP : "
	LOAD 15(GB), R2
	LOAD 14(GB), R3
	LOAD R3, R1
	CMP #0x0.0p0, R1
	BEQ div_zero_error
	DIV R3, R2
	BOV overflow_error
	LOAD R2, R1
	WFLOAT
	WNL
	WNL
	WSTR "--- Test sin(pi/4) ---"
	WNL
	ADDSP #2
	LOAD 11(GB), R2
	STORE R2, 0(SP)
	LOAD 11(GB), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 1(R2), R2
	LOAD #4, R3
	FLOAT R3, R3
	BOV overflow_error
	LOAD R3, R1
	CMP #0x0.0p0, R1
	BEQ div_zero_error
	DIV R3, R2
	BOV overflow_error
	STORE R2, -1(SP)
	LOAD 0(SP), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 0(R2), R2
	BSR 2(R2)
	SUBSP #2
	STORE R0, 12(GB)
	WSTR "sin(pi/4) = "
	LOAD 12(GB), R2
	LOAD R2, R1
	WFLOAT
	WNL
	LOAD #0x1.6a09eep-1, R2
	LOAD 12(GB), R3
	SUB R3, R2
	BOV overflow_error
	STORE R2, 15(GB)
	WSTR "Erreur absolue = "
	LOAD 15(GB), R2
	LOAD R2, R1
	WFLOAT
	WNL
	ADDSP #2
	LOAD 11(GB), R2
	STORE R2, 0(SP)
	LOAD 11(GB), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 1(R2), R2
	LOAD #4, R3
	FLOAT R3, R3
	BOV overflow_error
	LOAD R3, R1
	CMP #0x0.0p0, R1
	BEQ div_zero_error
	DIV R3, R2
	BOV overflow_error
	STORE R2, -1(SP)
	LOAD 0(SP), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 0(R2), R2
	BSR 7(R2)
	SUBSP #2
	STORE R0, 14(GB)
	WSTR "ULP(sin(pi/4)) = "
	LOAD 14(GB), R2
	LOAD R2, R1
	WFLOAT
	WNL
	WSTR "L'erreur en ULP : "
	LOAD 15(GB), R2
	LOAD 14(GB), R3
	LOAD R3, R1
	CMP #0x0.0p0, R1
	BEQ div_zero_error
	DIV R3, R2
	BOV overflow_error
	LOAD R2, R1
	WFLOAT
	WNL
	WNL
	WSTR "--- Test sin(pi/2) ---"
	WNL
	ADDSP #2
	LOAD 11(GB), R2
	STORE R2, 0(SP)
	LOAD 11(GB), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 1(R2), R2
	LOAD #2, R3
	FLOAT R3, R3
	BOV overflow_error
	LOAD R3, R1
	CMP #0x0.0p0, R1
	BEQ div_zero_error
	DIV R3, R2
	BOV overflow_error
	STORE R2, -1(SP)
	LOAD 0(SP), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 0(R2), R2
	BSR 2(R2)
	SUBSP #2
	STORE R0, 12(GB)
	WSTR "sin(pi/2) = "
	LOAD 12(GB), R2
	LOAD R2, R1
	WFLOAT
	WNL
	LOAD #0x1.0p0, R2
	LOAD 12(GB), R3
	SUB R3, R2
	BOV overflow_error
	STORE R2, 15(GB)
	WSTR "Erreur absolue = "
	LOAD 15(GB), R2
	LOAD R2, R1
	WFLOAT
	WNL
	ADDSP #2
	LOAD 11(GB), R2
	STORE R2, 0(SP)
	LOAD 11(GB), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 1(R2), R2
	LOAD #2, R3
	FLOAT R3, R3
	BOV overflow_error
	LOAD R3, R1
	CMP #0x0.0p0, R1
	BEQ div_zero_error
	DIV R3, R2
	BOV overflow_error
	STORE R2, -1(SP)
	LOAD 0(SP), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 0(R2), R2
	BSR 7(R2)
	SUBSP #2
	STORE R0, 14(GB)
	WSTR "ULP(sin(pi/2)) = "
	LOAD 14(GB), R2
	LOAD R2, R1
	WFLOAT
	WNL
	WSTR "L'erreur en ULP : "
	LOAD 15(GB), R2
	LOAD 14(GB), R3
	LOAD R3, R1
	CMP #0x0.0p0, R1
	BEQ div_zero_error
	DIV R3, R2
	BOV overflow_error
	LOAD R2, R1
	WFLOAT
	WNL
	WNL
	WSTR "--- Test atan ---"
	WNL
	ADDSP #2
	LOAD 11(GB), R2
	STORE R2, 0(SP)
	LOAD #0x1.99999ap-1, R0
	STORE R0, -1(SP)
	LOAD 0(SP), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 0(R2), R2
	BSR 4(R2)
	SUBSP #2
	STORE R0, 12(GB)
	WSTR "atan(0.8) = "
	LOAD 12(GB), R2
	LOAD R2, R1
	WFLOAT
	WNL
	LOAD #0x1.5977a8p-1, R2
	LOAD 12(GB), R3
	SUB R3, R2
	BOV overflow_error
	STORE R2, 15(GB)
	WSTR "Erreur absolue = "
	LOAD 15(GB), R2
	LOAD R2, R1
	WFLOAT
	WNL
	ADDSP #2
	LOAD 11(GB), R2
	STORE R2, 0(SP)
	LOAD #0x1.5977a8p-1, R0
	STORE R0, -1(SP)
	LOAD 0(SP), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 0(R2), R2
	BSR 7(R2)
	SUBSP #2
	STORE R0, 14(GB)
	WSTR "ULP(atan(0.8)) = "
	LOAD 14(GB), R2
	LOAD R2, R1
	WFLOAT
	WNL
	WSTR "L'erreur en ULP : "
	LOAD 15(GB), R2
	LOAD 14(GB), R3
	LOAD R3, R1
	CMP #0x0.0p0, R1
	BEQ div_zero_error
	DIV R3, R2
	BOV overflow_error
	LOAD R2, R1
	WFLOAT
	WNL
	WNL
	WSTR "--- Test cos(pi) ---"
	WNL
	ADDSP #2
	LOAD 11(GB), R2
	STORE R2, 0(SP)
	LOAD 11(GB), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 1(R2), R2
	STORE R2, -1(SP)
	LOAD 0(SP), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 0(R2), R2
	BSR 3(R2)
	SUBSP #2
	STORE R0, 12(GB)
	WSTR "cos(pi) = "
	LOAD 12(GB), R2
	LOAD R2, R1
	WFLOAT
	WNL
	LOAD #0x1.0p0, R2
	OPP R2, R2
	BOV overflow_error
	LOAD 12(GB), R3
	SUB R3, R2
	BOV overflow_error
	STORE R2, 15(GB)
	WSTR "Erreur absolue = "
	LOAD 15(GB), R2
	LOAD R2, R1
	WFLOAT
	WNL
	ADDSP #2
	LOAD 11(GB), R2
	STORE R2, 0(SP)
	LOAD #0x1.0p0, R2
	OPP R2, R2
	BOV overflow_error
	STORE R2, -1(SP)
	LOAD 0(SP), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 0(R2), R2
	BSR 7(R2)
	SUBSP #2
	STORE R0, 14(GB)
	WSTR "ULP(cos(pi)) = "
	LOAD 14(GB), R2
	LOAD R2, R1
	WFLOAT
	WNL
	WSTR "L'erreur en ULP : "
	LOAD 15(GB), R2
	LOAD 14(GB), R3
	LOAD R3, R1
	CMP #0x0.0p0, R1
	BEQ div_zero_error
	DIV R3, R2
	BOV overflow_error
	LOAD R2, R1
	WFLOAT
	WNL
	WNL
	WSTR "===== FIN DEMONSTRATION ====="
	WNL
	HALT
; end main program
;  ************************************************************
;  *  GENERATION DES INITS ET DES BODY METHODES DES CLASSES   *
;  ************************************************************
init.Math:
	TSTO #0
	BOV stack_overflow_error
	LOAD -2(LB), R2
	LOAD #0x0.0p0, R1
	STORE R1, 1(R2)
	LOAD -2(LB), R2
	LOAD #0x1.921fb6p1, R0
	STORE R0, 1(R2)
	RTS
code.Object.equals:
	LOAD -2(LB), R0
	CMP -3(LB), R0
	SEQ R1
	RTS
code.Math.sin:

        ; Beginning of main instructions:
            ; ==========================
            ; SIN
            ; ==========================
            PUSH R2
            PUSH R3
            ; neg = false
            LOAD #0, R1
            STORE R1, 9(LB)

            ; if (x < 0)
            LOAD -3(LB), R2
            CMP #0.0, R2
            SLT R3
            CMP #0, R3
            BEQ SIN_X_POX

            OPP R2, R2
            STORE R2, -3(LB)
            LOAD #1, R1
            STORE R1, 9(LB)

        SIN_X_POX:

            ; k = x * 0.636619772367581343075535
            LOAD -3(LB), R2
            LOAD #0.636619772367581343075535, R3
            MUL R3, R2
            STORE R2, 3(LB)

            ; arrondi de k
            CMP #0.0, R2
            SGE R3
            CMP #0, R3
            BEQ SIN_K_NEG

            LOAD #0.5, R1
            ADD R1, R2
            BRA SIN_K_CAST

        SIN_K_NEG:
            LOAD #-0.5, R1
            ADD R1, R2

        SIN_K_CAST:
            INT R2, R2
            FLOAT R2, R2
            STORE R2, 3(LB)

            ; r = x - k*pi/2 + k*eps
            LOAD -3(LB), R1
            LOAD #-1.57079637050628662109375, R3
            FMA R2, R3

            LOAD R3, R1
            LOAD #4.371138828673792886547744274139404296875e-8, R3
            FMA R2, R3
            STORE R3, 4(LB)

            ; v = k % 4
            LOAD 3(LB), R1
            INT R1, R1
            LOAD R1, R2
            SHR R2
            SHR R2
            SHL R2
            SHL R2
            SUB R2, R1
            STORE R1, 6(LB)

            ; r2 = r*r
            LOAD 4(LB), R2
            MUL R2, R2
            STORE R2, 5(LB)

            ; dispatch
            LOAD 6(LB), R1
            CMP #0, R1
            BEQ SIN_CASE0
            CMP #1, R1
            BEQ SIN_CASE1
            CMP #2, R1
            BEQ SIN_CASE2
            CMP #3, R1
            BEQ SIN_CASE3
            BRA SIN_END

        SIN_CASE0:
            LOAD 5(LB), R1
            PUSH R1
            LOAD 4(LB), R2
            PUSH R2
            BSR SIN_POLY_SIN
            SUBSP #2
            BRA SIGN_ADJ_SIN

        SIN_CASE1:
            LOAD 5(LB), R1
            PUSH R1
            BSR COS_POLY_SIN
            SUBSP #1
            BRA SIGN_ADJ_SIN

        SIN_CASE2:
            LOAD 5(LB), R1
            PUSH R1
            LOAD 4(LB), R2
            PUSH R2
            BSR SIN_POLY_SIN
            SUBSP #2
            OPP R0, R0
            BRA SIGN_ADJ_SIN

        SIN_CASE3:
            LOAD 5(LB), R1
            PUSH R1
            BSR COS_POLY_SIN
            SUBSP #1
            OPP R0, R0

        SIGN_ADJ_SIN:
            LOAD 9(LB), R1
            CMP #0, R1
            BEQ SIN_PRINT_RES
            OPP R0, R0
            BRA SIN_PRINT_RES

        SIN_POLY_SIN:
            LOAD #2.800547008519060909748077392578125e-6, R1
            LOAD -3(LB), R3
            LOAD #-1.98499110410921275615692138671875e-4, R2
            FMA R3, R2

            LOAD #8.33337195217609405517578125e-3, R1
            FMA R3, R2

            LOAD #-0.16666667163372039794921875, R1
            FMA R3, R2

            LOAD #1.0, R1
            FMA R3, R2

            LOAD -2(LB), R3
            MUL R3, R2
            LOAD R2, R0
            RTS

        COS_POLY_SIN:
            LOAD #2.443256744300015270709991455078125e-5, R2
            LOAD -2(LB), R3

            LOAD #-1.388731063343584537506103515625e-3, R1
            FMA R3, R2

            LOAD #4.16666455566883087158203125e-2, R1
            FMA R3, R2
            LOAD R2, R1

            LOAD #-0.5, R1
            FMA R3, R2

            LOAD #1.0, R1
            FMA R3, R2

            LOAD R2, R0
            
            RTS

        SIN_END : 
            LOAD #0.0, R0

        SIN_PRINT_RES :
            POP R3
            POP R2
            RTS
    
code.Math.cos:

        ; Beginning of main instructions:
            ; ==========================
            ; if (x < 0) x = -x
            ; ==========================
            PUSH R2
            PUSH R3
            LOAD -3(LB), R2
            CMP #0.0, R2
            SLT R3
            CMP #0, R3
            BEQ COS_X_POS

            OPP R2, R2
            STORE R2, -3(LB)

        COS_X_POS:

            ; ==========================
            ; k = x * 0.6366197723675813
            ; ==========================
            LOAD #0.636619772367581343075535, R3
            MUL R3, R2
            STORE R2, 2(LB)

            ; ==========================
            ; Arrondi de k
            ; ==========================
            CMP #0.0, R2
            SGE R3
            CMP #0, R3
            BEQ K_NEG

            LOAD #0.5, R1
            ADD R1, R2
            BRA K_CAST

        K_NEG:
            LOAD #-0.5, R1
            ADD R1, R2

        K_CAST:
            INT R2, R2
            FLOAT R2, R2
            STORE R2, 2(LB)

            ; ==========================
            ; r = x - k*pi/2 + k*eps
            ; ==========================
            LOAD -3(LB), R1
            LOAD #-1.57079637050628662109375, R3
            FMA R2, R3              ; R3 = x - k*pi/2

            LOAD R3, R1
            LOAD #4.371138828673792886547744274139404296875e-8, R3
            FMA R2, R3              ; R3 = r
            STORE R3, 3(LB)

            ; ==========================
            ; v = k % 4
            ; ==========================
            LOAD 2(LB), R1
            INT R1, R1
            LOAD R1, R2
            SHR R2
            SHR R2
            SHL R2
            SHL R2
            SUB R2, R1
            STORE R1, 5(LB)

            ; ==========================
            ; r2 = r * r
            ; ==========================
            LOAD 3(LB), R2
            MUL R2, R2
            STORE R2, 4(LB)

            ; ==========================
            ; Dispatch selon v
            ; ==========================
            LOAD 5(LB), R1
            CMP #0, R1
            BEQ CASE0
            CMP #1, R1
            BEQ CASE1
            CMP #2, R1
            BEQ CASE2
            CMP #3, R1
            BEQ CASE3
            BRA COS_END

            CASE0:
            LOAD 4(LB), R1
            PUSH R1
            BSR COS_POLY
            SUBSP #1
            BRA COS_PRINT

            CASE1:
            LOAD 4(LB), R2
            PUSH R2
            LOAD 3(LB), R1
            PUSH R1
            BSR SIN_POLY
            SUBSP #2
            OPP R0, R0              ; -resSin
            BRA COS_PRINT

            CASE2:
            LOAD 4(LB), R1
            PUSH R1
            BSR COS_POLY
            ;LOAD -7(LB), R0
            SUBSP #1
            OPP R0, R0              ; -resCos
            BRA COS_PRINT

            CASE3:
            LOAD 4(LB), R2
            PUSH R2
            LOAD 3(LB), R1
            PUSH R1
            BSR SIN_POLY
            SUBSP #2
            BRA COS_PRINT


        SIN_POLY :
            ; ==========================
            ; resSin (polynôme de sin)
            ; ==========================
            LOAD #2.800547008519060909748077392578125e-6, R1
            LOAD -3(LB), R3
            LOAD #-1.98499110410921275615692138671875e-4, R2
            FMA R3, R2

            LOAD #8.33337195217609405517578125e-3, R1
            FMA R3, R2

            LOAD #-0.16666667163372039794921875, R1
            FMA R3, R2

            LOAD #1.0, R1
            FMA R3, R2

            LOAD -2(LB), R3          ; r
            MUL R3, R2
            LOAD R2, R0
            RTS

        COS_POLY :
            ; ==========================
            ; resCos (polynôme de cos)
            ; ==========================
            LOAD #2.443256744300015270709991455078125e-5, R2
            LOAD -2(LB), R3

            LOAD #-1.388731063343584537506103515625e-3, R1
            FMA R3, R2

            LOAD #4.16666455566883087158203125e-2, R1
            FMA R3, R2

            LOAD #-0.5, R1
            FMA R3, R2

            LOAD #1.0, R1
            FMA R3, R2
            LOAD R2, R0
            RTS
            

        COS_END:
            LOAD #0.0, R0

        COS_PRINT:
            POP R3
            POP R2
            RTS
    
code.Math.atan:

        ; Beginning of main instructions:
        ; ===============================
        ; atan(x) - Implémentation complète
        ; ===============================

        PUSH R2
        PUSH R3
        ; neg = false
        LOAD #0, R1
        STORE R1, 9(LB)

        ; -------------------------------
        ; if (x < 0)
        ; -------------------------------
        LOAD -3(LB), R2
        CMP #0.0, R2
        SLT R3
        CMP #0, R3
        BEQ ATAN_X_POS

        OPP R2, R2
        STORE R2, -3(LB)

        LOAD #1, R1
        STORE R1, 9(LB)

        ATAN_X_POS:

        ; -------------------------------
        ; if (x <= 1.0)
        ; -------------------------------
        LOAD -3(LB), R2
        CMP #0x1.0p0, R2
        SLE R3
        CMP #0, R3
        BEQ X_GT_1

        ; ===== CAS |x| <= 1 =====

        ; x2 = x*x
        LOAD -3(LB), R2
        MUL R2, R2
        STORE R2, 4(LB)

        ; p = polynôme P(x2)
        LOAD #0.05503292, R2
        LOAD 4(LB), R3
        LOAD #-0.16182011, R1
        FMA R3, R2

        LOAD #0.16252689, R1
        FMA R3, R2

        LOAD #-0.02731802, R1
        FMA R3, R2

        LOAD #-0.1054397, R1
        FMA R3, R2

        LOAD #0.19565304, R1
        FMA R3, R2

        LOAD #-0.33318959, R1
        FMA R3, R2

        STORE R2, 7(LB)

        ; res = x + x*x2*p
        LOAD -3(LB), R1
        LOAD 4(LB), R3
        MUL R1, R3
        LOAD 7(LB), R2
        FMA R3, R2
        STORE R2, 3(LB)

        BRA ATAN_END

        ; ===== CAS x > 1 =====
        X_GT_1:

        ; y = 1/x
        LOAD #0x1.0p0, R2
        LOAD -3(LB), R3
        DIV R3, R2
        STORE R2, 2(LB)

        ; y2 = y*y
        LOAD 2(LB), R2
        MUL R2, R2
        STORE R2, 5(LB)

        ; q = polynôme Q(y2)
        LOAD #-0.06155182, R2
        LOAD 5(LB), R3
        LOAD #0.18379633, R1
        FMA R3, R2

        LOAD #-0.19430663, R1
        FMA R3, R2

        LOAD #0.05846937, R1
        FMA R3, R2

        LOAD #0.07056377, R1
        FMA R3, R2

        LOAD #-0.13813491, R1
        FMA R3, R2

        LOAD #0.1998436, R1
        FMA R3, R2

        STORE R2, 8(LB)

        ; corr = y - y^3/3 + y^5*q
        LOAD 2(LB), R2
        LOAD 5(LB), R3
        MUL R3, R2          ; y^3
        PUSH R2             ; sauvegarde y^3  dans 0(SP)
        DIV #0x1.8p1, R2    ; /3

        LOAD 2(LB), R1
        SUB R2, R1       ; y - y^3/3

        LOAD 5(LB), R2
        MUL 0(SP), R2    ; y^5
        POP R2
        LOAD 8(LB), R3
        FMA R2, R3     ; y - y^3/3 + y^5*q
        STORE R3, 6(LB)

        ; res = pi/2 - corr
        LOAD #0x1.921fb54442d18p+0, R2
        LOAD 6(LB), R3
        SUB R3, R2
        STORE R2, 3(LB)

        ; -------------------------------
        ; if (neg) res = -res
        ; -------------------------------
        ATAN_END:
        LOAD 9(LB), R1
        CMP #0, R1
        BEQ ATAN_PRINT_RES

        LOAD 3(LB), R2
        OPP R2, R2
        STORE R2, 3(LB)

        ; -------------------------------
        ; affichage
        ; -------------------------------
        ATAN_PRINT_RES:
        
        LOAD 3(LB), R0
        POP R3
        POP R2
        RTS
    
code.Math.asin_asm:

        ; Beginning of main instructions:

            ; ===============================
            ; asin(x) 
            ; ===============================

            PUSH R2
            PUSH R3
            ; -------------------------------
            ; test domaine |x| <= 1
            ; -------------------------------
            ; if (x > 1.0)
            LOAD -3(LB), R2
            CMP #1.0, R2
            SGT R3
            CMP #0, R3
            BNE ASIN_ERROR

            ; if (x < -1.0)
            LOAD -3(LB), R2
            CMP #-1.0, R2
            SLT R3
            CMP #0, R3
            BNE ASIN_ERROR

            ; -------------------------------
            ; neg = 0
            ; -------------------------------
            LOAD #0, R1
            STORE R1, 8(LB)

            ; -------------------------------
            ; if (x < 0)
            ; -------------------------------
            LOAD -3(LB), R2
            CMP #0.0, R2
            SLT R3
            CMP #0, R3
            BEQ ASIN_X_POS

            OPP R2, R2
            STORE R2, -3(LB)

            LOAD #1, R1
            STORE R1, 8(LB)

        ASIN_X_POS:

            ; -------------------------------
            ; if (x <= 0.5)
            ; -------------------------------
            LOAD -3(LB), R2
            CMP #0.5, R2
            SLE R3
            CMP #0, R3
            BEQ X_GT_HALF

            ; ===== CAS |x| <= 0.5 =====

            ; x2 = x * x
            LOAD -3(LB), R2
            MUL R2, R2
            STORE R2, 2(LB)

            ; p = polynôme P(x2)
            LOAD #3.4441731870174407958984375e-2, R2
            LOAD 2(LB), R3
            LOAD #1.664256118237972259521484375e-2, R1
            FMA R3, R2

            LOAD #3.12243886291980743408203125e-2, R1
            FMA R3, R2

            LOAD #4.45862747728824615478515625e-2, R1
            FMA R3, R2

            LOAD #7.50015079975128173828125e-2, R1
            FMA R3, R2

            LOAD #0.1666666567325592041015625, R1
            FMA R3, R2

            STORE R2, 3(LB)

            ; res = x + x * x2 * p
            LOAD -3(LB), R1
            LOAD 2(LB), R3
            MUL R1, R3          ; x*x2
            LOAD 3(LB), R2
            FMA R3, R2         ; x*x2*p + x
            STORE R2, 9(LB)

            BRA ASIN_END

            ; ===== CAS 0.5 < x <= 1 =====
        X_GT_HALF:

            ; u = 1 - x
            LOAD #1.0, R2
            LOAD -3(LB), R3
            SUB R3, R2
            STORE R2, 4(LB)

            ; a = 2*u
            LOAD #2.0, R3
            MUL R3, R2
            STORE R2, 5(LB)

            ; s = 1
            LOAD #1.0, R2
            STORE R2, 6(LB)

            ; ---- Newton sqrt(a) : 4 itérations ----

            ; s = 0.5*(s + a/s)
            LOAD 5(LB), R3
            DIV R2, R3
            ADD R3, R2
            MUL #0.5, R2
            STORE R2, 6(LB)
            ; itération 2
            LOAD 5(LB), R3
            DIV R2, R3
            ADD R3, R2
            MUL #0.5, R2
            STORE R2, 6(LB)
            ; itération 3
            LOAD 5(LB), R3
            DIV R2, R3
            ADD R3, R2
            MUL #0.5, R2
            STORE R2, 6(LB)
            ; itération 4
            LOAD 5(LB), R3
            DIV R2, R3
            ADD R3, R2
            MUL #0.5, R2
            STORE R2, 6(LB)
            ; ---- r(u) ----
            LOAD #0.0013274972, R2
            LOAD 4(LB), R3

            LOAD #1.4921810e-03, R1
            FMA R3, R2

            LOAD #5.6961202e-03, R1
            FMA R3, R2

            LOAD #1.8734945e-02, R1
            FMA R3, R2

            LOAD #8.3334103e-02, R1
            FMA R3, R2

            LOAD #-9.3774277e-09, R1
            FMA R3, R2

            STORE R2, 7(LB)

            ; res = pi/2 - s*(1+r)
            LOAD #1.0, R3
            ADD R3, R2         ; 1+r

            LOAD 6(LB), R3
            OPP R3, R3
            LOAD #1.5707963267948966, R1
            FMA R3, R2

            STORE R2, 9(LB)

            ; -------------------------------
            ; if (neg) res = -res
            ; -------------------------------
        ASIN_END:
            LOAD 8(LB), R1
            CMP #0, R1
            BEQ ASIN_PRINT_RES

            LOAD 9(LB), R2
            OPP R2, R2
            STORE R2, 9(LB)

        ASIN_PRINT_RES:
            LOAD 9(LB), R0
            POP R3
            POP R2
            RTS
            
        ASIN_ERROR:
            ;WSTR \"Erreur la valeur doit être comprise entre -1 et 1.\"
            ;WNL
            ERROR
    
code.Math.asin:
	TSTO #7
	BOV stack_overflow_error
	PUSH R2
	PUSH R3
	PUSH R4
	LOAD -3(LB), R2
	LOAD #0x1.0p0, R3
	OPP R3, R3
	BOV overflow_error
	CMP R3, R2
	BLT E_Fin_Or.1
	LOAD -3(LB), R2
	CMP #0x1.0p0, R2
	BLE E_Sinon.1
E_Fin_Or.1:
	WSTR "Erreur : la valeur pour l'arcsinus doit être comprise entre -1 et 1."
	WNL
	BRA E_Fin_if.1
E_Sinon.1:
	ADDSP #2
	LOAD -2(LB), R2
	STORE R2, 0(SP)
	LOAD -3(LB), R2
	STORE R2, -1(SP)
	LOAD 0(SP), R2
	CMP #null, R2
	BEQ dereferencement.null
	LOAD 0(R2), R2
	BSR 5(R2)
	SUBSP #2
	LOAD R0, R0
	BRA fin.Math.asin
E_Fin_if.1:
	BRA absence_return_error
fin.Math.asin:
	POP R4
	POP R3
	POP R2
	RTS
code.Math.ulp:

        ; =============================================================================
        ; FONCTION ULP (Unit in the Last Place)
        ; =============================================================================

            ; Récupération du paramètre f
            ; ATTENTION : Dans une méthode, -2(LB) = this, donc param = -3(LB)
            PUSH R2
            PUSH R3
            LOAD -3(LB), R2      

            ; --- 1. Valeur Absolue ---
            LOAD #0.0, R1
            CMP R1, R2
            BGE ULP_CHECK_SUBNORMAL
            OPP R2, R2           ; R2 = |f|

        ULP_CHECK_SUBNORMAL:
            ; --- 2. Gestion Subnormaux et Zéro ---
            ; Seuil normal = 2^-126 (environ 1.17549435e-38)
            LOAD #0x1.0p-126, R1 
            CMP R1, R2
            BGE ULP_INIT_ALGO    ; Si |f| >= Seuil, calcul normal

            ; Cas Subnormal (ou 0.0) -> ULP fixe (2^-149)
            ; C'est la plus petite valeur positive possible
            LOAD #0x0.000002p-126, R0 
            BRA ULP_FIN

            ; --- 3.Recherche de l'exposant ---
        ULP_INIT_ALGO:
            LOAD #0x1.0p-23, R3  ; ULP de départ (pour 1.0) -> epsilon machine
            LOAD #0x1.0p1, R1    ; 2.0
            LOAD #0x1.0p0, R0    ; 1.0

        ULP_LOOP_DOWN:
            CMP R1, R2           ; Tant que |f| >= 2.0
            BLT ULP_LOOP_UP
            DIV R1, R2           ; f = f / 2
            MUL R1, R3           ; ulp = ulp * 2
            BRA ULP_LOOP_DOWN

        ULP_LOOP_UP:
            CMP R0, R2           ; Tant que |f| < 1.0
            BGE ULP_FIN_CALCUL
            MUL R1, R2           ; f = f * 2
            DIV R1, R3           ; ulp = ulp / 2
            BRA ULP_LOOP_UP

        ULP_FIN_CALCUL:
            LOAD R3, R0
            
        ULP_FIN:
            POP R3
            POP R2
            RTS          ; Le résultat (l'ULP calculé) va dans R0

    
;  ************************************************************
;  * AJOUT DES LABELS ERREURS DEMANDÉES PAR LE PROGRAMME DECA *
;  ************************************************************
stack_overflow_error:
	WSTR "Error: Stack Overflow"
	WNL
	ERROR
overflow_error:
	WSTR "Error: Overflow sur Float"
	WNL
	ERROR
div_zero_error:
	WSTR "Erreur : division par 0"
	WNL
	ERROR
tas_plein:
	WSTR "Erreur : le tas est plein, impossible d'allouer de la memoire"
	WNL
	ERROR
absence_return_error:
	WSTR "Erreur : Absence de return dans le corps d'une methode "
	WNL
	ERROR
dereferencement.null:
	WSTR "Erreur : Dereferencement null"
	WNL
	ERROR
