// Grenoble INP - Ensimag projet GL -*- mode: java -*-
// Library for class Math of Deca, coded in Deca

class Math {
    float PI = 3.14159265358979323846; 
    
    float sin(float f) 
    asm("
        ; Beginning of main instructions:
            ; ==========================
            ; SIN
            ; ==========================
            PUSH R2
            PUSH R3
            ; neg = false
            LOAD #0, R1
            STORE R1, 9(LB)

            ; if (x < 0)
            LOAD -3(LB), R2
            CMP #0.0, R2
            SLT R3
            CMP #0, R3
            BEQ SIN_X_POX

            OPP R2, R2
            STORE R2, -3(LB)
            LOAD #1, R1
            STORE R1, 9(LB)

        SIN_X_POX:

            ; k = x * 0.636619772367581343075535
            LOAD -3(LB), R2
            LOAD #0.636619772367581343075535, R3
            MUL R3, R2
            STORE R2, 3(LB)

            ; arrondi de k
            CMP #0.0, R2
            SGE R3
            CMP #0, R3
            BEQ SIN_K_NEG

            LOAD #0.5, R1
            ADD R1, R2
            BRA SIN_K_CAST

        SIN_K_NEG:
            LOAD #-0.5, R1
            ADD R1, R2

        SIN_K_CAST:
            INT R2, R2
            FLOAT R2, R2
            STORE R2, 3(LB)

            ; r = x - k*pi/2 + k*eps
            LOAD -3(LB), R1
            LOAD #-1.57079637050628662109375, R3
            FMA R2, R3

            LOAD R3, R1
            LOAD #4.371138828673792886547744274139404296875e-8, R3
            FMA R2, R3
            STORE R3, 4(LB)

            ; v = k % 4
            LOAD 3(LB), R1
            INT R1, R1
            LOAD R1, R2
            SHR R2
            SHR R2
            SHL R2
            SHL R2
            SUB R2, R1
            STORE R1, 6(LB)

            ; r2 = r*r
            LOAD 4(LB), R2
            MUL R2, R2
            STORE R2, 5(LB)

            ; dispatch
            LOAD 6(LB), R1
            CMP #0, R1
            BEQ SIN_CASE0
            CMP #1, R1
            BEQ SIN_CASE1
            CMP #2, R1
            BEQ SIN_CASE2
            CMP #3, R1
            BEQ SIN_CASE3
            BRA SIN_END

        SIN_CASE0:
            LOAD 5(LB), R1
            PUSH R1
            LOAD 4(LB), R2
            PUSH R2
            BSR SIN_POLY_SIN
            SUBSP #2
            BRA SIGN_ADJ_SIN

        SIN_CASE1:
            LOAD 5(LB), R1
            PUSH R1
            BSR COS_POLY_SIN
            SUBSP #1
            BRA SIGN_ADJ_SIN

        SIN_CASE2:
            LOAD 5(LB), R1
            PUSH R1
            LOAD 4(LB), R2
            PUSH R2
            BSR SIN_POLY_SIN
            SUBSP #2
            OPP R0, R0
            BRA SIGN_ADJ_SIN

        SIN_CASE3:
            LOAD 5(LB), R1
            PUSH R1
            BSR COS_POLY_SIN
            SUBSP #1
            OPP R0, R0

        SIGN_ADJ_SIN:
            LOAD 9(LB), R1
            CMP #0, R1
            BEQ SIN_PRINT_RES
            OPP R0, R0
            BRA SIN_PRINT_RES

        SIN_POLY_SIN:
            LOAD #2.800547008519060909748077392578125e-6, R1
            LOAD -3(LB), R3
            LOAD #-1.98499110410921275615692138671875e-4, R2
            FMA R3, R2

            LOAD #8.33337195217609405517578125e-3, R1
            FMA R3, R2

            LOAD #-0.16666667163372039794921875, R1
            FMA R3, R2

            LOAD #1.0, R1
            FMA R3, R2

            LOAD -2(LB), R3
            MUL R3, R2
            LOAD R2, R0
            RTS

        COS_POLY_SIN:
            LOAD #2.443256744300015270709991455078125e-5, R2
            LOAD -2(LB), R3

            LOAD #-1.388731063343584537506103515625e-3, R1
            FMA R3, R2

            LOAD #4.16666455566883087158203125e-2, R1
            FMA R3, R2
            LOAD R2, R1

            LOAD #-0.5, R1
            FMA R3, R2

            LOAD #1.0, R1
            FMA R3, R2

            LOAD R2, R0
            
            RTS

        SIN_END : 
            LOAD #0.0, R0

        SIN_PRINT_RES :
            POP R3
            POP R2
            RTS
    ");
    
    float cos(float f) 
    asm("
        ; Beginning of main instructions:
            ; ==========================
            ; if (x < 0) x = -x
            ; ==========================
            PUSH R2
            PUSH R3
            LOAD -3(LB), R2
            CMP #0.0, R2
            SLT R3
            CMP #0, R3
            BEQ COS_X_POS

            OPP R2, R2
            STORE R2, -3(LB)

        COS_X_POS:

            ; ==========================
            ; k = x * 0.6366197723675813
            ; ==========================
            LOAD #0.636619772367581343075535, R3
            MUL R3, R2
            STORE R2, 2(LB)

            ; ==========================
            ; Arrondi de k
            ; ==========================
            CMP #0.0, R2
            SGE R3
            CMP #0, R3
            BEQ K_NEG

            LOAD #0.5, R1
            ADD R1, R2
            BRA K_CAST

        K_NEG:
            LOAD #-0.5, R1
            ADD R1, R2

        K_CAST:
            INT R2, R2
            FLOAT R2, R2
            STORE R2, 2(LB)

            ; ==========================
            ; r = x - k*pi/2 + k*eps
            ; ==========================
            LOAD -3(LB), R1
            LOAD #-1.57079637050628662109375, R3
            FMA R2, R3              ; R3 = x - k*pi/2

            LOAD R3, R1
            LOAD #4.371138828673792886547744274139404296875e-8, R3
            FMA R2, R3              ; R3 = r
            STORE R3, 3(LB)

            ; ==========================
            ; v = k % 4
            ; ==========================
            LOAD 2(LB), R1
            INT R1, R1
            LOAD R1, R2
            SHR R2
            SHR R2
            SHL R2
            SHL R2
            SUB R2, R1
            STORE R1, 5(LB)

            ; ==========================
            ; r2 = r * r
            ; ==========================
            LOAD 3(LB), R2
            MUL R2, R2
            STORE R2, 4(LB)

            ; ==========================
            ; Dispatch selon v
            ; ==========================
            LOAD 5(LB), R1
            CMP #0, R1
            BEQ CASE0
            CMP #1, R1
            BEQ CASE1
            CMP #2, R1
            BEQ CASE2
            CMP #3, R1
            BEQ CASE3
            BRA COS_END

            CASE0:
            LOAD 4(LB), R1
            PUSH R1
            BSR COS_POLY
            SUBSP #1
            BRA COS_PRINT

            CASE1:
            LOAD 4(LB), R2
            PUSH R2
            LOAD 3(LB), R1
            PUSH R1
            BSR SIN_POLY
            SUBSP #2
            OPP R0, R0              ; -resSin
            BRA COS_PRINT

            CASE2:
            LOAD 4(LB), R1
            PUSH R1
            BSR COS_POLY
            ;LOAD -7(LB), R0
            SUBSP #1
            OPP R0, R0              ; -resCos
            BRA COS_PRINT

            CASE3:
            LOAD 4(LB), R2
            PUSH R2
            LOAD 3(LB), R1
            PUSH R1
            BSR SIN_POLY
            SUBSP #2
            BRA COS_PRINT


        SIN_POLY :
            ; ==========================
            ; resSin (polynôme de sin)
            ; ==========================
            LOAD #2.800547008519060909748077392578125e-6, R1
            LOAD -3(LB), R3
            LOAD #-1.98499110410921275615692138671875e-4, R2
            FMA R3, R2

            LOAD #8.33337195217609405517578125e-3, R1
            FMA R3, R2

            LOAD #-0.16666667163372039794921875, R1
            FMA R3, R2

            LOAD #1.0, R1
            FMA R3, R2

            LOAD -2(LB), R3          ; r
            MUL R3, R2
            LOAD R2, R0
            RTS

        COS_POLY :
            ; ==========================
            ; resCos (polynôme de cos)
            ; ==========================
            LOAD #2.443256744300015270709991455078125e-5, R2
            LOAD -2(LB), R3

            LOAD #-1.388731063343584537506103515625e-3, R1
            FMA R3, R2

            LOAD #4.16666455566883087158203125e-2, R1
            FMA R3, R2

            LOAD #-0.5, R1
            FMA R3, R2

            LOAD #1.0, R1
            FMA R3, R2
            LOAD R2, R0
            RTS
            

        COS_END:
            LOAD #0.0, R0

        COS_PRINT:
            POP R3
            POP R2
            RTS
    ");

    float atan(float f) 
    asm("
        ; Beginning of main instructions:
        ; ===============================
        ; atan(x) - Implémentation complète
        ; ===============================

        PUSH R2
        PUSH R3
        ; neg = false
        LOAD #0, R1
        STORE R1, 9(LB)

        ; -------------------------------
        ; if (x < 0)
        ; -------------------------------
        LOAD -3(LB), R2
        CMP #0.0, R2
        SLT R3
        CMP #0, R3
        BEQ ATAN_X_POS

        OPP R2, R2
        STORE R2, -3(LB)

        LOAD #1, R1
        STORE R1, 9(LB)

        ATAN_X_POS:

        ; -------------------------------
        ; if (x <= 1.0)
        ; -------------------------------
        LOAD -3(LB), R2
        CMP #0x1.0p0, R2
        SLE R3
        CMP #0, R3
        BEQ X_GT_1

        ; ===== CAS |x| <= 1 =====

        ; x2 = x*x
        LOAD -3(LB), R2
        MUL R2, R2
        STORE R2, 4(LB)

        ; p = polynôme P(x2)
        LOAD #0.05503292, R2
        LOAD 4(LB), R3
        LOAD #-0.16182011, R1
        FMA R3, R2

        LOAD #0.16252689, R1
        FMA R3, R2

        LOAD #-0.02731802, R1
        FMA R3, R2

        LOAD #-0.1054397, R1
        FMA R3, R2

        LOAD #0.19565304, R1
        FMA R3, R2

        LOAD #-0.33318959, R1
        FMA R3, R2

        STORE R2, 7(LB)

        ; res = x + x*x2*p
        LOAD -3(LB), R1
        LOAD 4(LB), R3
        MUL R1, R3
        LOAD 7(LB), R2
        FMA R3, R2
        STORE R2, 3(LB)

        BRA ATAN_END

        ; ===== CAS x > 1 =====
        X_GT_1:

        ; y = 1/x
        LOAD #0x1.0p0, R2
        LOAD -3(LB), R3
        DIV R3, R2
        STORE R2, 2(LB)

        ; y2 = y*y
        LOAD 2(LB), R2
        MUL R2, R2
        STORE R2, 5(LB)

        ; q = polynôme Q(y2)
        LOAD #-0.06155182, R2
        LOAD 5(LB), R3
        LOAD #0.18379633, R1
        FMA R3, R2

        LOAD #-0.19430663, R1
        FMA R3, R2

        LOAD #0.05846937, R1
        FMA R3, R2

        LOAD #0.07056377, R1
        FMA R3, R2

        LOAD #-0.13813491, R1
        FMA R3, R2

        LOAD #0.1998436, R1
        FMA R3, R2

        STORE R2, 8(LB)

        ; corr = y - y^3/3 + y^5*q
        LOAD 2(LB), R2
        LOAD 5(LB), R3
        MUL R3, R2          ; y^3
        PUSH R2             ; sauvegarde y^3  dans 0(SP)
        DIV #0x1.8p1, R2    ; /3

        LOAD 2(LB), R1
        SUB R2, R1       ; y - y^3/3

        LOAD 5(LB), R2
        MUL 0(SP), R2    ; y^5
        POP R2
        LOAD 8(LB), R3
        FMA R2, R3     ; y - y^3/3 + y^5*q
        STORE R3, 6(LB)

        ; res = pi/2 - corr
        LOAD #0x1.921fb54442d18p+0, R2
        LOAD 6(LB), R3
        SUB R3, R2
        STORE R2, 3(LB)

        ; -------------------------------
        ; if (neg) res = -res
        ; -------------------------------
        ATAN_END:
        LOAD 9(LB), R1
        CMP #0, R1
        BEQ ATAN_PRINT_RES

        LOAD 3(LB), R2
        OPP R2, R2
        STORE R2, 3(LB)

        ; -------------------------------
        ; affichage
        ; -------------------------------
        ATAN_PRINT_RES:
        
        LOAD 3(LB), R0
        POP R3
        POP R2
        RTS
    ");

    float asin_asm(float f)
    asm("
        ; Beginning of main instructions:

            ; ===============================
            ; asin(x) 
            ; ===============================

            PUSH R2
            PUSH R3
            ; -------------------------------
            ; test domaine |x| <= 1
            ; -------------------------------
            ; if (x > 1.0)
            LOAD -3(LB), R2
            CMP #1.0, R2
            SGT R3
            CMP #0, R3
            BNE ASIN_ERROR

            ; if (x < -1.0)
            LOAD -3(LB), R2
            CMP #-1.0, R2
            SLT R3
            CMP #0, R3
            BNE ASIN_ERROR

            ; -------------------------------
            ; neg = 0
            ; -------------------------------
            LOAD #0, R1
            STORE R1, 8(LB)

            ; -------------------------------
            ; if (x < 0)
            ; -------------------------------
            LOAD -3(LB), R2
            CMP #0.0, R2
            SLT R3
            CMP #0, R3
            BEQ ASIN_X_POS

            OPP R2, R2
            STORE R2, -3(LB)

            LOAD #1, R1
            STORE R1, 8(LB)

        ASIN_X_POS:

            ; -------------------------------
            ; if (x <= 0.5)
            ; -------------------------------
            LOAD -3(LB), R2
            CMP #0.5, R2
            SLE R3
            CMP #0, R3
            BEQ X_GT_HALF

            ; ===== CAS |x| <= 0.5 =====

            ; x2 = x * x
            LOAD -3(LB), R2
            MUL R2, R2
            STORE R2, 2(LB)

            ; p = polynôme P(x2)
            LOAD #3.4441731870174407958984375e-2, R2
            LOAD 2(LB), R3
            LOAD #1.664256118237972259521484375e-2, R1
            FMA R3, R2

            LOAD #3.12243886291980743408203125e-2, R1
            FMA R3, R2

            LOAD #4.45862747728824615478515625e-2, R1
            FMA R3, R2

            LOAD #7.50015079975128173828125e-2, R1
            FMA R3, R2

            LOAD #0.1666666567325592041015625, R1
            FMA R3, R2

            STORE R2, 3(LB)

            ; res = x + x * x2 * p
            LOAD -3(LB), R1
            LOAD 2(LB), R3
            MUL R1, R3          ; x*x2
            LOAD 3(LB), R2
            FMA R3, R2         ; x*x2*p + x
            STORE R2, 9(LB)

            BRA ASIN_END

            ; ===== CAS 0.5 < x <= 1 =====
        X_GT_HALF:

            ; u = 1 - x
            LOAD #1.0, R2
            LOAD -3(LB), R3
            SUB R3, R2
            STORE R2, 4(LB)

            ; a = 2*u
            LOAD #2.0, R3
            MUL R3, R2
            STORE R2, 5(LB)

            ; s = 1
            LOAD #1.0, R2
            STORE R2, 6(LB)

            ; ---- Newton sqrt(a) : 4 itérations ----

            ; s = 0.5*(s + a/s)
            LOAD 5(LB), R3
            DIV R2, R3
            ADD R3, R2
            MUL #0.5, R2
            STORE R2, 6(LB)
            ; itération 2
            LOAD 5(LB), R3
            DIV R2, R3
            ADD R3, R2
            MUL #0.5, R2
            STORE R2, 6(LB)
            ; itération 3
            LOAD 5(LB), R3
            DIV R2, R3
            ADD R3, R2
            MUL #0.5, R2
            STORE R2, 6(LB)
            ; itération 4
            LOAD 5(LB), R3
            DIV R2, R3
            ADD R3, R2
            MUL #0.5, R2
            STORE R2, 6(LB)
            ; ---- r(u) ----
            LOAD #0.0013274972, R2
            LOAD 4(LB), R3

            LOAD #1.4921810e-03, R1
            FMA R3, R2

            LOAD #5.6961202e-03, R1
            FMA R3, R2

            LOAD #1.8734945e-02, R1
            FMA R3, R2

            LOAD #8.3334103e-02, R1
            FMA R3, R2

            LOAD #-9.3774277e-09, R1
            FMA R3, R2

            STORE R2, 7(LB)

            ; res = pi/2 - s*(1+r)
            LOAD #1.0, R3
            ADD R3, R2         ; 1+r

            LOAD 6(LB), R3
            OPP R3, R3
            LOAD #1.5707963267948966, R1
            FMA R3, R2

            STORE R2, 9(LB)

            ; -------------------------------
            ; if (neg) res = -res
            ; -------------------------------
        ASIN_END:
            LOAD 8(LB), R1
            CMP #0, R1
            BEQ ASIN_PRINT_RES

            LOAD 9(LB), R2
            OPP R2, R2
            STORE R2, 9(LB)

        ASIN_PRINT_RES:
            LOAD 9(LB), R0
            POP R3
            POP R2
            RTS
            
        ASIN_ERROR:
            ;WSTR \"Erreur la valeur doit être comprise entre -1 et 1.\"
            ;WNL
            ERROR
    ");

    float asin(float f) {
        if (f < -1.0 || f > 1.0) {
            println("Erreur : la valeur pour l'arcsinus doit être comprise entre -1 et 1.");
        } else {
            return this.asin_asm(f);
        }
    }
    
    
    float ulp(float f)
    asm("
        ; =============================================================================
        ; FONCTION ULP (Unit in the Last Place)
        ; =============================================================================

            ; Récupération du paramètre f
            ; ATTENTION : Dans une méthode, -2(LB) = this, donc param = -3(LB)
            PUSH R2
            PUSH R3
            LOAD -3(LB), R2      

            ; --- 1. Valeur Absolue ---
            LOAD #0.0, R1
            CMP R1, R2
            BGE ULP_CHECK_SUBNORMAL
            OPP R2, R2           ; R2 = |f|

        ULP_CHECK_SUBNORMAL:
            ; --- 2. Gestion Subnormaux et Zéro ---
            ; Seuil normal = 2^-126 (environ 1.17549435e-38)
            LOAD #0x1.0p-126, R1 
            CMP R1, R2
            BGE ULP_INIT_ALGO    ; Si |f| >= Seuil, calcul normal

            ; Cas Subnormal (ou 0.0) -> ULP fixe (2^-149)
            ; C'est la plus petite valeur positive possible
            LOAD #0x0.000002p-126, R0 
            BRA ULP_FIN

            ; --- 3.Recherche de l'exposant ---
        ULP_INIT_ALGO:
            LOAD #0x1.0p-23, R3  ; ULP de départ (pour 1.0) -> epsilon machine
            LOAD #0x1.0p1, R1    ; 2.0
            LOAD #0x1.0p0, R0    ; 1.0

        ULP_LOOP_DOWN:
            CMP R1, R2           ; Tant que |f| >= 2.0
            BLT ULP_LOOP_UP
            DIV R1, R2           ; f = f / 2
            MUL R1, R3           ; ulp = ulp * 2
            BRA ULP_LOOP_DOWN

        ULP_LOOP_UP:
            CMP R0, R2           ; Tant que |f| < 1.0
            BGE ULP_FIN_CALCUL
            MUL R1, R2           ; f = f * 2
            DIV R1, R3           ; ulp = ulp / 2
            BRA ULP_LOOP_UP

        ULP_FIN_CALCUL:
            LOAD R3, R0
            
        ULP_FIN:
            POP R3
            POP R2
            RTS          ; Le résultat (l'ULP calculé) va dans R0

    ");

}


// End of Deca Math library
