<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MethodCall.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Deca Compiler</a> &gt; <a href="index.source.html" class="el_package">fr.ensimag.deca.tree</a> &gt; <span class="el_source">MethodCall.java</span></div><h1>MethodCall.java</h1><pre class="source lang-java linenums">package fr.ensimag.deca.tree;
import static org.mockito.Mockito.never;

import java.io.PrintStream;
import java.util.List;

import org.apache.commons.lang.Validate;

import fr.ensimag.deca.DecacCompiler;
import fr.ensimag.deca.context.ClassDefinition;
import fr.ensimag.deca.context.ContextualError;
import fr.ensimag.deca.context.EnvironmentExp;
import fr.ensimag.deca.context.ExpDefinition;
import fr.ensimag.deca.context.MethodDefinition;
import fr.ensimag.deca.context.Type;
import fr.ensimag.deca.context.Signature;
import fr.ensimag.deca.tools.IndentPrintStream;
import fr.ensimag.ima.pseudocode.DVal;
import fr.ensimag.ima.pseudocode.GPRegister;
import fr.ensimag.ima.pseudocode.Label;
import fr.ensimag.ima.pseudocode.NullOperand;
import fr.ensimag.ima.pseudocode.Register;
import fr.ensimag.ima.pseudocode.RegisterOffset;
import fr.ensimag.ima.pseudocode.instructions.ADDSP;
import fr.ensimag.ima.pseudocode.instructions.BEQ;
import fr.ensimag.ima.pseudocode.instructions.BSR;
import fr.ensimag.ima.pseudocode.instructions.CMP;
import fr.ensimag.ima.pseudocode.instructions.FLOAT;
import fr.ensimag.ima.pseudocode.instructions.INT;
import fr.ensimag.ima.pseudocode.instructions.LOAD;
import fr.ensimag.ima.pseudocode.instructions.PUSH;
import fr.ensimag.ima.pseudocode.instructions.STORE;
import fr.ensimag.ima.pseudocode.instructions.SUBSP;

public class MethodCall extends AbstractExpr {
    private final AbstractExpr object;
    private final AbstractIdentifier methodName;
    private final ListExpr arguments;

<span class="fc" id="L40">    public MethodCall(AbstractExpr object, AbstractIdentifier methodName, ListExpr arguments) {</span>
<span class="fc" id="L41">        Validate.notNull(methodName);</span>
<span class="fc" id="L42">        this.object = object;</span>
<span class="fc" id="L43">        this.methodName = methodName;</span>
<span class="fc" id="L44">        this.arguments = arguments;</span>
<span class="fc" id="L45">    }</span>
    public AbstractExpr getObject() {
<span class="fc" id="L47">        return object;</span>
    }
    public AbstractIdentifier getMethodName() {
<span class="fc" id="L50">        return methodName;</span>
    }
    public ListExpr getArguments() {
<span class="fc" id="L53">        return arguments;   </span>
    }

    @Override
    public void setLocation(Location location){
<span class="fc" id="L58">        super.setLocation(location);</span>
<span class="fc" id="L59">    }</span>

    @Override
    public Type verifyExpr(DecacCompiler compiler, EnvironmentExp localEnv, ClassDefinition currentClass)
            throws ContextualError {
        EnvironmentExp envExp2;
<span class="fc bfc" id="L65" title="All 2 branches covered.">        if (object!=null){</span>
<span class="fc" id="L66">            Type typeClass2 = object.verifyExpr(compiler, localEnv, currentClass);</span>
<span class="fc bfc" id="L67" title="All 2 branches covered.">            if (!typeClass2.isClass()) {</span>
<span class="fc" id="L68">                throw new ContextualError(&quot;The object is not of class type&quot;, getLocation());</span>
            }
<span class="fc" id="L70">            envExp2 = typeClass2.asClassType(&quot;The object is not of class type&quot;, getLocation()).getDefinition().getMembers();</span>
<span class="fc" id="L71">        }</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">        else if (currentClass != null) {</span>
<span class="fc" id="L73">            envExp2 = currentClass.getMembers();</span>
        } 
        else {
<span class="fc" id="L76">            throw new ContextualError(&quot;A method call without an object cannot be used outside a class&quot;, getLocation());</span>
        }
<span class="fc" id="L78">        ExpDefinition def = methodName.verifyIdent(envExp2);</span>
<span class="fc bfc" id="L79" title="All 2 branches covered.">        if (!def.isMethod()) {</span>
<span class="fc" id="L80">            throw new ContextualError(&quot;The method is not defined&quot;, getLocation());</span>
        }
<span class="fc" id="L82">        MethodDefinition methodDef = def.asMethodDefinition(&quot;The method is not defined&quot;, getLocation());</span>
<span class="fc" id="L83">        Signature sig = methodDef.getSignature();</span>

<span class="fc" id="L85">        List&lt;AbstractExpr&gt; args = arguments.getList(); // The rvalues</span>

        // Verification of the number of arguments Vérifie nombre d'arguments
<span class="fc bfc" id="L88" title="All 2 branches covered.">        if (args.size() != sig.size()) {</span>
<span class="fc" id="L89">            throw new ContextualError(&quot;Wrong number of arguments: expected &quot; + sig.size() +&quot;, got &quot; + args.size(),getLocation());</span>
        }

        // Verification of each argument with verifyRValue
<span class="fc bfc" id="L93" title="All 2 branches covered.">        for (int i = 0; i &lt; args.size(); i++) {</span>
<span class="fc" id="L94">            AbstractExpr argExpr = args.get(i).verifyRValue(compiler, localEnv, currentClass, sig.paramNumber(i));</span>
        }
        
<span class="fc" id="L97">        setType(methodDef.getType());</span>
<span class="fc" id="L98">        return methodDef.getType();</span>
    }



    @Override
    public void decompile(IndentPrintStream s) {
<span class="fc bfc" id="L105" title="All 2 branches covered.">        if (getObject() != null) {</span>
<span class="fc" id="L106">            getObject().decompile(s);</span>
<span class="fc" id="L107">            s.print(&quot;.&quot;);</span>
        }
<span class="fc" id="L109">        getMethodName().decompile(s);</span>
<span class="fc" id="L110">        s.print(&quot;(&quot;);</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">        if (!getArguments().isEmpty()) {</span>
<span class="fc" id="L112">            getArguments().decompile(s);</span>
        }
        
<span class="fc" id="L115">        s.print(&quot;)&quot;);</span>
<span class="fc" id="L116">    }</span>

    @Override
    protected void prettyPrintChildren(PrintStream s, String prefix) {
<span class="fc bfc" id="L120" title="All 2 branches covered.">        if (object != null) {</span>
<span class="fc" id="L121">            object.prettyPrint(s, prefix, false);</span>
        }
<span class="fc" id="L123">        methodName.prettyPrint(s, prefix, false);</span>
<span class="fc" id="L124">        arguments.prettyPrint(s, prefix, true);</span>
<span class="fc" id="L125">    }</span>

    @Override
    protected void iterChildren(TreeFunction f) {
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">        if (object != null) {</span>
<span class="nc" id="L130">            object.iter(f);</span>
        }
<span class="fc" id="L132">        methodName.iter(f);</span>
<span class="fc" id="L133">        arguments.iter(f);</span>
<span class="fc" id="L134">    }</span>

    // @Ousmane
    @Override
    protected GPRegister codeGenInst(DecacCompiler compiler) {
        
        // On réserve de la place pour les trois paramètres
<span class="fc" id="L141">        int nbParams = arguments.getList().size() + 1; // +1 pour le paramètre implicite this</span>
<span class="fc" id="L142">        compiler.addInstruction(new ADDSP(nbParams));</span>

        // on empile le param implicite this (l'objet)
<span class="fc" id="L145">        DVal reg = object.codeGenInst(compiler);</span>
<span class="fc" id="L146">        compiler.addInstruction(new STORE( (GPRegister)reg, new RegisterOffset(0, Register.SP)));</span>
<span class="fc" id="L147">        compiler.libererRegistre();</span>
        

        // on empile les autres paramètres
<span class="fc" id="L151">        List&lt;AbstractExpr&gt; args = arguments.getList();</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">        for (int i = 0; i &lt; args.size(); i++) {</span>
<span class="fc" id="L153">            boolean libereReg = true;</span>
<span class="fc" id="L154">            reg = args.get(i).codeGenInst(compiler);</span>

            // on gere le fait que  reg peut etre un immediat : 
<span class="pc bpc" id="L157" title="1 of 2 branches missed.">            if(reg instanceof GPRegister == false){</span>
<span class="nc" id="L158">                compiler.addInstruction(new LOAD(reg, Register.R0));</span>
<span class="nc" id="L159">                reg = Register.R0;</span>
<span class="nc" id="L160">                libereReg = false;</span>
            }

<span class="fc" id="L163">            compiler.addInstruction(new STORE((GPRegister)reg, new RegisterOffset(-(i + 1), Register.SP)));</span>
<span class="pc bpc" id="L164" title="1 of 2 branches missed.">            if (libereReg) {</span>
<span class="fc" id="L165">                compiler.libererRegistre();</span>
            }
        }

<span class="fc" id="L169">        GPRegister regAppel = compiler.utiliserRegistre();</span>

        // On récupère le paramètre implicite
<span class="fc" id="L172">        compiler.addInstruction(new LOAD(new RegisterOffset(0, Register.SP), regAppel));</span>


        // On teste s'il est égal à null
<span class="fc" id="L176">        compiler.addInstruction(new CMP(new NullOperand(), regAppel));</span>
<span class="fc" id="L177">        compiler.addDereferencementNullLabel();</span>
<span class="fc" id="L178">        compiler.addInstruction(new BEQ(new Label(&quot;dereferencement.null&quot;)));</span>



        // appel de la méthode
<span class="fc" id="L183">        MethodDefinition methodDef = methodName.getMethodDefinition();</span>

<span class="pc bpc" id="L185" title="1 of 2 branches missed.">        if (object instanceof Cast){</span>
            // On récupère le label de la méthode dans la classe cible du Cast
<span class="nc" id="L187">            Cast cast = (Cast) object;</span>
<span class="nc" id="L188">            Type targetType = cast.getType();</span>
            
            // On génère le label : code.NomClasse.NomMethode
<span class="nc" id="L191">            Label staticLabel = new Label(&quot;code.&quot; + targetType.getName().getName() + &quot;.&quot; + methodName.getName().getName());</span>
<span class="nc" id="L192">            compiler.addInstruction(new BSR(staticLabel));</span>
<span class="nc" id="L193">        }else{</span>
            //On récupère l'adresse de la table des méthodes
<span class="fc" id="L195">            compiler.addInstruction(new LOAD(new RegisterOffset(0, regAppel), regAppel));</span>

<span class="fc" id="L197">            compiler.addInstruction(new BSR(new RegisterOffset(methodDef.getIndex() + 1, regAppel)));</span>

        }

        // on depile les parametres : 
<span class="fc" id="L202">        compiler.addInstruction(new SUBSP(nbParams));</span>
        


        // liberation du registre
<span class="fc" id="L207">        compiler.libererRegistre();</span>

        // on retourne R0 d'après la spé : @arevoir
<span class="fc" id="L210">        return Register.R0;</span>
    }


//     @Override
// protected GPRegister codeGenInst(DecacCompiler compiler) {
//     // 1. On réserve la place
//     int nbParams = arguments.getList().size() + 1;
//     compiler.addInstruction(new ADDSP(nbParams));

//     // 2. Empiler 'this'
//     DVal regObj = object.codeGenInst(compiler);
//     compiler.addInstruction(new STORE( (GPRegister)regObj, new RegisterOffset(0, Register.SP)));
//     compiler.libererRegistre();

//     // 3. Empiler les arguments
//     List&lt;AbstractExpr&gt; args = arguments.getList();
//     for (int i = 0; i &lt; args.size(); i++) {
//          DVal regArg = args.get(i).codeGenInst(compiler);
//         // Gérer le cas où regArg est un immédiat
//         if (regArg instanceof GPRegister == false) {
//             compiler.addInstruction(new LOAD(regArg, Register.R0));
//             regArg = Register.R0;
//         }
//         // On utilise -(i+1) comme dans le poly
//         compiler.addInstruction(new STORE((GPRegister)regArg, new RegisterOffset(-(i + 1), Register.SP)));
//         compiler.libererRegistre();
//     }

//     // 4. Charger 'this' pour le test de null et l'appel
//     GPRegister res = compiler.utiliserRegistre(); // On prend un registre propre
//     compiler.addInstruction(new LOAD(new RegisterOffset(0, Register.SP), res));

//     // 5. Test de null (Exactement comme le poly)
//     compiler.addInstruction(new CMP(new NullOperand(), res));
//     compiler.addDereferencementNullLabel();
//     compiler.addInstruction(new BEQ(new Label(&quot;dereferencement.null&quot;)));

//     // 6. Appel (VTable ou Cast)
//     if (object instanceof Cast) {
//         Type targetType = ((Cast) object).getType();
//         Label staticLabel = new Label(&quot;code.&quot; + targetType.getName().getName() + &quot;.&quot; + methodName.getName().getName());
//         compiler.addInstruction(new BSR(staticLabel));
//     } else {
//         // LOAD 0(res), res : récupère l'adresse de la VTable
//         compiler.addInstruction(new LOAD(new RegisterOffset(0, res), res));
//         // BSR index+1(res)
//         MethodDefinition methodDef = methodName.getMethodDefinition();
//         compiler.addInstruction(new BSR(new RegisterOffset(methodDef.getIndex(), res)));
//     }

//     // 7. Dépiler
//     compiler.addInstruction(new SUBSP(nbParams));

//     // 8. Récupérer le résultat de R0 vers notre registre 'res'
//     compiler.addInstruction(new LOAD(Register.R0, res));

//     return res;
// }


    // @Ousmane , je dois implementer cette fonctionnalite

    @Override
    public int simuleExecutionNbRegistres(DecacCompiler compiler){
<span class="fc" id="L275">        int maxReg = 0;</span>

        // On simule l'évaluation de l'objet de manière isolée.
<span class="fc" id="L278">        compiler.commencerSimulationRegistres(true);</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        if (object != null) {</span>
<span class="fc" id="L280">            maxReg = object.simuleExecutionNbRegistres(compiler);</span>
        } else {
            // Si l'objet est null, c'est un appel sur 'this' implicite, qui nécessite un registre.
<span class="fc" id="L283">            maxReg = compiler.simulerAllocationRegistre();</span>
        }
<span class="fc" id="L285">        compiler.resetGestionnaireRegistres(false);</span>

        // On cherche le pic d'utilisation des registres parmi l'évaluation de chaque argument.
        // Chaque argument est évalué indépendamment.
<span class="fc bfc" id="L289" title="All 2 branches covered.">        for (AbstractExpr a : arguments.getList()) {</span>
<span class="fc" id="L290">            compiler.commencerSimulationRegistres(true);</span>
<span class="fc" id="L291">            int argRegs = a.simuleExecutionNbRegistres(compiler);</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">            if (argRegs &gt; maxReg) {</span>
<span class="fc" id="L293">                maxReg = argRegs;</span>
            }
<span class="fc" id="L295">            compiler.resetGestionnaireRegistres(false);</span>
<span class="fc" id="L296">        }</span>

<span class="fc" id="L298">        return maxReg;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>