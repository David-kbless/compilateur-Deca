<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractOpCmp.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Deca Compiler</a> &gt; <a href="index.source.html" class="el_package">fr.ensimag.deca.tree</a> &gt; <span class="el_source">AbstractOpCmp.java</span></div><h1>AbstractOpCmp.java</h1><pre class="source lang-java linenums">package fr.ensimag.deca.tree;

import fr.ensimag.deca.context.Type;
import fr.ensimag.ima.pseudocode.DVal;
import fr.ensimag.ima.pseudocode.GPRegister;
import fr.ensimag.ima.pseudocode.Label;
import fr.ensimag.deca.DecacCompiler;
import fr.ensimag.deca.context.ClassDefinition;
import fr.ensimag.deca.context.ContextualError;
import fr.ensimag.deca.context.EnvironmentExp;
import org.apache.commons.lang.Validate;
import fr.ensimag.ima.pseudocode.RegisterOffset;
import fr.ensimag.ima.pseudocode.instructions.BRA;
import fr.ensimag.ima.pseudocode.instructions.CMP;
import fr.ensimag.ima.pseudocode.instructions.FLOAT;
import fr.ensimag.ima.pseudocode.instructions.LOAD;
import fr.ensimag.ima.pseudocode.Register;
/**
 *
 * @author gl54
 * @date 01/01/2026
 */
public abstract class AbstractOpCmp extends AbstractBinaryExpr {

    public AbstractOpCmp(AbstractExpr leftOperand, AbstractExpr rightOperand) {
<span class="fc" id="L26">        super(leftOperand, rightOperand);</span>
<span class="fc" id="L27">    }</span>

    @Override
    public Type verifyExpr(DecacCompiler compiler, EnvironmentExp localEnv,
            ClassDefinition currentClass) throws ContextualError {

<span class="fc" id="L33">        Type t1 = this.getLeftOperand().verifyExpr(compiler, localEnv, currentClass);</span>
<span class="fc" id="L34">        Type t2 = this.getRightOperand().verifyExpr(compiler, localEnv, currentClass);</span>
<span class="fc" id="L35">        Validate.notNull(t1);</span>
<span class="fc" id="L36">        Validate.notNull(t2);</span>

<span class="fc" id="L38">        Type resultType = typeOfOperation(compiler, t1, t2);</span>
<span class="fc" id="L39">        this.setType(resultType);</span>
<span class="fc" id="L40">        return resultType;</span>
    }

    @Override
    protected Type typeOfOperation(DecacCompiler compiler, Type t1, Type t2) throws ContextualError {
<span class="pc bpc" id="L45" title="2 of 8 branches missed.">        if ((t1.isInt() || t1.isFloat()) &amp;&amp; (t2.isInt() || t2.isFloat())) {</span>
<span class="fc" id="L46">            return compiler.environmentType.BOOLEAN;</span>
        }
<span class="nc" id="L48">        throw new ContextualError(&quot;Comparison operators require int or float operands&quot;, getLocation());</span>
    }

    @Override
    public boolean isComparisonOp() {
<span class="nc" id="L53">        return true;</span>
    }


    // @Override
    // protected GPRegister codeGenInst(DecacCompiler compiler){
    //     GPRegister operande2 = getRightOperand().codeGenInst(compiler);
    //     GPRegister operande1 = getLeftOperand().codeGenInst(compiler);


    //     // gestion de la convertion lorsqu'une op est int et l'autre float
    //     if(getRightOperand().getType().isInt() &amp;&amp; getLeftOperand().getType().isFloat()){
    //         compiler.addInstruction(new FLOAT(operande2, operande2));
    //     }else if(getLeftOperand().getType().isInt() &amp;&amp; getRightOperand().getType().isFloat()){
    //         compiler.addInstruction(new FLOAT(operande1, operande1));
    //     }
        

    //     // si on a du pusher une operande : 
    //     if(operande1 == operande2){
    //         // on utilise R0 pour remplacer le defaut de registre 
    //         compiler.addInstruction(new LOAD(new RegisterOffset(0, Register.SP), Register.R0));

    //         compiler.addInstruction(new CMP(Register.R0, operande1));
    //         codeGenOpComp(compiler, operande1, Register.R0);
    //     }else{
    //         compiler.addInstruction(new CMP(operande2, operande1));
    //         codeGenOpComp(compiler, operande1, operande2);


    //         compiler.addInstruction(new LOAD(operande1, operande2));
    //         compiler.libererRegistre();
    //     }

    //     return operande2;
    // }


    //---------------
    protected abstract GPRegister codeGenOpComp(DecacCompiler compiler, GPRegister operande1, GPRegister operande2);

    @Override
    protected void codeGenVrai(DecacCompiler compiler, Label E) {
        // @Ousmane : On compare et on branche si la condition VRAIE est remplie
<span class="fc" id="L97">        codeGenCompare(compiler);</span>
<span class="fc" id="L98">        branchVrai(compiler, E);</span>
<span class="fc" id="L99">    }</span>

    @Override
    protected void codeGenFaux(DecacCompiler compiler, Label E) {
        // @Ousmane : On compare et on branche si la condition FAUSSE est remplie
<span class="fc" id="L104">        codeGenCompare(compiler);</span>
<span class="fc" id="L105">        branchFaux(compiler, E);</span>
<span class="fc" id="L106">    }</span>

    
    protected void codeGenCompare(DecacCompiler compiler) {
<span class="fc" id="L110">        GPRegister operande1 = getOperande1(compiler, getLeftOperand());</span>
<span class="fc" id="L111">        DVal operande2 = getOperande2(compiler, operande1, getRightOperand());</span>
        // @Ousmane : Génération de l'instruction CMP
        // Si operande1 a été poussé sur la pile par manque de registres
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">        if (operande1 == operande2) {</span>
<span class="nc" id="L115">            compiler.addInstruction(new LOAD(new RegisterOffset(0, Register.SP), Register.R0));</span>
<span class="nc" id="L116">            compiler.addInstruction(new CMP(operande2, Register.R0));</span>
        } else {
<span class="fc" id="L118">            compiler.addInstruction(new CMP(operande2, operande1));</span>
        }
        
        // On libère les registres utilisés pour les opérandes après le CMP
<span class="fc" id="L122">        compiler.libererRegistre(); </span>
<span class="fc" id="L123">        compiler.libererRegistre();</span>
<span class="fc" id="L124">    }</span>

//     @Override
// protected void codeGenVrai(DecacCompiler compiler, Label E) {
//     // 1. Évaluation des opérandes (Section 7.2)
//     GPRegister left = getLeftOperand().codeGenInst(compiler);
//     DVal right = getRightOperand().codeGenDVal(compiler); // Supporte #0, #1 ou un registre
    
//     // 2. Instruction de comparaison
//     compiler.addInstruction(new CMP(right, left));
    
//     // 3. Branchement spécifique à l'opérateur (ex: BEQ, BGT...)
//     branchVrai(compiler, E);
    
//     compiler.libererRegistre();
// }

// @Override
// protected void codeGenFaux(DecacCompiler compiler, Label E) {
//     GPRegister left = getLeftOperand().codeGenInst(compiler);
//     DVal right = getRightOperand().codeGenDVal(compiler);
    
//     compiler.addInstruction(new CMP(right, left));
    
//     // 4. Branchement INVERSE (ex: si on teste '==' et que c'est faux, on branche si '!=')
//     branchFaux(compiler, E);
    
//     compiler.libererRegistre();
// }


// @Override
//     protected void codeGenFaux(DecacCompiler compiler, Label E) {
//         // @Ousmane : On évalue les deux opérandes normalement
//         GPRegister left = getLeftOperand().codeGenInst(compiler);
//         GPRegister right = getRightOperand().codeGenInst(compiler);

//         // @Ousmane : On génère le CMP (Spé p. 222)
//         compiler.addInstruction(new CMP(right, left));
        
//         // @Ousmane : On appelle le branchement INVERSE (car Code(C, faux, E))
//         this.codeGenInverseBranch(compiler, E);

//         compiler.libererRegistre();
//         compiler.libererRegistre();
//     }

//     @Override
//     protected void codeGenVrai(DecacCompiler compiler, Label E) {
//         GPRegister left = getLeftOperand().codeGenInst(compiler);
//         GPRegister right = getRightOperand().codeGenInst(compiler);

//         compiler.addInstruction(new CMP(right, left));
        
//         // @Ousmane : On appelle le branchement DIRECT
//         this.codeGenDirectBranch(compiler, E);

//         compiler.libererRegistre();
//         compiler.libererRegistre();
//     }


    @Override
    protected GPRegister codeGenInst(DecacCompiler compiler) {
        // @Ousmane : Si on a besoin d'une valeur 0/1 (ex: boolean b = x &gt; y)
<span class="fc" id="L189">        GPRegister reg = compiler.utiliserRegistre();</span>
<span class="fc" id="L190">        Label eFaux = new Label(&quot;E_Faux_Cmp.&quot; + compiler.getAndIncOpBool());</span>
<span class="fc" id="L191">        Label eFin = new Label(&quot;E_Fin_Cmp.&quot; + compiler.getAndIncOpBool());</span>

<span class="fc" id="L193">        this.codeGenFaux(compiler, eFaux);</span>
        
<span class="fc" id="L195">        compiler.addInstruction(new LOAD(1, reg));</span>
<span class="fc" id="L196">        compiler.addInstruction(new BRA(eFin));</span>

<span class="fc" id="L198">        compiler.addLabel(eFaux);</span>
<span class="fc" id="L199">        compiler.addInstruction(new LOAD(0, reg));</span>

<span class="fc" id="L201">        compiler.addLabel(eFin);</span>
<span class="fc" id="L202">        return reg;</span>
    }

    // @Ousmane : Les sous-classes implémenteront le branchement spécifique (BNE, BEQ, BLT...)
    protected abstract void branchVrai(DecacCompiler compiler, Label E);
    protected abstract void branchFaux(DecacCompiler compiler, Label E);


}



</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>